### 유니온 파인드(Union-Find)
이름대로 union 연산, find 연산 두 개만을 지원하는 자료구조이다. 다른 말로는 'disjoint-set' 구조라고도 한다. disjoint한 집합을 표현하는 자료구조인데, 모든 두 집합의 교집합은 공집합이며 모든 집합의 합집합은 전체집합임을 의미한다.
기본적으로 이 자료구조는 트리의 집합인 숲(forest) 형태를 띈다. 다음 그림을 살펴보자.

![graph (2)](https://github.com/movingsummer/TIL/assets/111179843/e69552a2-e3ef-4761-a648-66fc5fb6a5cb)

초기 크기 N=8 인 유니온 파인드이다. 트리 컴포넌트 각각이 하나의 집합을 의미한다. 따라서 집합은 8개이며 각 집합은 하나의 원소만 포함하고 있다.

![graph (4)](https://github.com/movingsummer/TIL/assets/111179843/82e63b31-f063-4e7f-a0a5-89c4378aa29b)

몇 번의 연산이 이루어지고 난 후의 상황이다. 집합은 총 4개이다.

같은 집합, 즉 같은 트리에 속해있는지 확인하는 방법은 그 트리에서의 루트가 같은지 확인하면 된다. 이를 위한 연산이 **find**인데, 어떤 정점의 루트를 찾는 연산이다.

당연히 루트는 우리가 어떤 것으로 정하냐에 따라 달라질 수 있다. 여기에서는 2를 루트라고 생각하겠다.

```cpp
int find(int n) {
  if (p[n] < 0) return n;
  return find(p[n]);
}
```

재귀를 사용할 수 있는데, 구현 자체는 굉장히 간단하다. 자신의 부모를 가리키는 배열을 p라고 하고, 노드의 부모가 없는 것을 -1과 같이 음수로 나타낸다고 하자. 부모가 없으면 루트이므로 자기 자신을 리턴한다. 부모가 있다면 재귀적으로 계속 타고 올라간다.

이렇게 해서 루트가 같으면 같은 집합에 속해있다고 판단할 수 있다. find(3)과 find(4)는 둘 다 루트인 2를 리턴할 것이므로 같은 집합에 속해있다고 판단할 수 있다.

그러나, 재귀함수의 특성상 트리가 깊어질수록 호출이 굉장히 늘어날 것이다. 아래 그림을 살펴보자.

![graph (5)](https://github.com/movingsummer/TIL/assets/111179843/fe705a88-5067-4a00-b5f0-5a5756318d9d)

마찬가지로 2가 루트이다. find(7)을 실행할 때마다 6, 1, 3, 2를 타고 올라가게 될 것이다. 지금은 노드가 적지만 숫자가 굉장히 늘어난다면 실행 시간에 큰 영향을 미칠 수 있다. 개선할 방법이 없을까?

피보나치 수열을 생각해보자. 재귀로 구현했을 때는 이미 구했던 값을 계속해서 다시 계산하므로 메모이제이션을 사용해서 구했던 값을 저장해두는 방식으로 최적화를 한다.

유니온 파인드에서도 비슷하게 find를 통해 트리를 타고 올라갈 때, 해당 노드의 부모를 전부 루트로 바꿔버리면 된다.

```cpp
int find(int n) {
  if (p[n] < 0) return n;
  p[n] = find(p[n]);
  return p[n];
}
```

이렇게 한 줄 추가하는 것으로 성능이 굉장히 개선되는데, 엄청나다. find(7)을 실행하면 타고 올라가는 경로에서 모든 노드의 부모를 루트인 2로 재설정한다.

즉 p[6] = p[1] = p[3] = 2 가 되는 것이다. 따라서 다음에 find 연산을 할 때는 바로 루트를 리턴할 수 있다.

다음에 구현할 union 연산을 union by rank 기법을 이용해서 구현하게 된다면 크기가 N인 유니온 파인드에 find 연산을 M번 수행했을 때 시간복잡도는 **amortized O(Mlog*N)** 이 된다.

amortized란 순간순간은 해당 시간을 초과할 수 있지만, 전체적으로 보았을 때는 평균이 회귀한다는 것이다. amortized O(N)이라고 하면 순간적으로 O(N)을 초과할 수 있지만 결국에는 O(N)으로 회귀한다는 뜻이다.

수학적 증명에 대한 공부도 해야하는데 일단은 느낌만 이렇다고 하고 넘어갔다. 추가적인 학습이 필요한 부분이다.

다시 시간복잡도를 살펴보자. 저 로그스타 함수(log*)는 아커만 함수의 역함수로 엄청나게 느리게 증가하는데, N = 2^65536이라고 해도 그 값이 겨우 5이다. 따라서 사실상 N의 값에 상관없이 상수시간으로 취급하고 사실상의 시간복잡도는 O(M)이다.

위의 루트를 갱신하는 테크닉을 경로 압축(path compression)이라고 부른다.

다음으로 두 집합을 합치는 union 연산을 살펴보자.

find 연산을 구현했으므로 합칠 두 집합이 같은지 아닌지는 쉽게 구분할 수 있다. 루트가 같으면 같은 집합이고, 다르면 다른 집합이다.

만약 다른 집합이라면 한 루트를 다른 루트의 자식으로 만들어버리면 된다.

![graph (4)](https://github.com/movingsummer/TIL/assets/111179843/82e63b31-f063-4e7f-a0a5-89c4378aa29b)

![graph (6)](https://github.com/movingsummer/TIL/assets/111179843/6c6e595f-85b6-4d71-9341-e9d587061e05)

루트 7의 부모를 루트 2로 만들어서 두 집합을 합친 것이다.

```cpp
void merge(int a, int b) {
  a = find(a);
  b = find(b);
  if (a == b) return;
  p[a] = b;
}
```

예제 코드에서는 p[a] = b와 같이 작성했지만, 구체적으로 어떻게 할지는 작성자의 마음이다. 더 효율적인 연산을 위해서는 큰 집합이 루트가 되도록 만들 수도 있다. 합친 후 find를 통해 경로 압축이 되는 것을 생각하면 큰 집합이 루트가 되는 게 더 효율적인 것을 알 수 있다.

p 배열에서 루트가 갖는 음수값의 절댓값을 집합의 크기로 설정한다면 이렇게 조건문을 통해 큰 집합에 합쳐지도록 할 수 있다.

```cpp
void merge(int a, int b) {
  a = find(a);
  b = find(b);
  if (a == b) return;
  if (p[a] > p[b]) {
    p[b] += p[a];
    p[a] = b;
  } else {
    p[a] += p[b];
    p[b] = a;
  }
}
```

p의 초기값을 -1로 설정해두면 된다.

---
참고자료
https://blog.naver.com/kks227/220791837179
